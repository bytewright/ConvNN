import os
import configargparse
import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
import pylab
import json
import random
import matplotlib.cm as cmx
import matplotlib.colors as colors

csv_delimiter = ';'
iter_index = 0
acc_index = 1
loss_index = 2


def get_cmap(N):
    '''Returns a function that maps each index in 0, 1, ... N-1 to a distinct
    RGB color.'''
    color_norm  = colors.Normalize(vmin=0, vmax=N-1)
    scalar_map = cmx.ScalarMappable(norm=color_norm, cmap='hsv')
    def map_index_to_rgb_color(index):
        return scalar_map.to_rgba(index)
    return map_index_to_rgb_color


def load_data(data_file):
    #delimiter = ';'
    test_data = []
    with open(data_file, 'r') as f:
        for line in f.readlines():
            line = line.rstrip()
            if line.split(csv_delimiter).__len__() < 3:
                print('incomplete line found')
            else:
                test_data.append([data for data in line.split(csv_delimiter) if data is not ''])

    return test_data[1:]


if __name__ == "__main__":

    configpath = os.path.join(os.path.dirname(__file__), 'plotter_config.ini')
    parser = configargparse.ArgParser(default_config_files=[configpath])
    parser.add_argument('--json_path', help='path to reference test data, generated by caffe parse_log.py')
    #parser.add_argument('--output', help='path to test data, generated by caffe parse_log.py')
    parser.add_argument('--output_png_path', help='path to png, will be overwritten by this script')
    # parser.set_defaults(DEBUG=True)
    args = parser.parse_args()

    # load data
    plot_datas = []
    line_names = []
    data_path_dict = json.load(open(args.json_path, 'r'))
    min_size = 99100000
    for path_index in data_path_dict:
        if 'ignore' in data_path_dict[path_index].keys():
            continue
        line_names.append(data_path_dict[path_index]['name'])

        plot_data = load_data(data_path_dict[path_index]['csv_path'])
        print '{}:\t{} iters'.format(data_path_dict[path_index]['name'], plot_data[-1][0])
        plot_datas.append(plot_data)
        if int(plot_data[-1][0]) < min_size:
            print '{} is new min size'.format(int(plot_data[-1][0]))
            min_size = int(plot_data[-1][0])

    # cut data to min size
    print 'min iters in data is:'+str(min_size)
    iters_list = []
    acc_list = []
    loss_list = []
    for data in plot_datas:
        list_min_iter_index = min_size
        if data[-1][0] > min_size:
            for i in range(data.__len__()):
                if int(data[i][0]) > min_size:
                    list_min_iter_index = i
                    break
                list_min_iter_index = i
        iterations = [int(x[iter_index]) for x in data[:list_min_iter_index]]
        accuracy = [x[acc_index] for x in data[:list_min_iter_index]]
        loss = [x[loss_index] for x in data[:list_min_iter_index]]
        iters_list.append(iterations)
        acc_list.append(accuracy)
        loss_list.append(loss)

    print 'found {} viable datapoints to plot'.format(min_size)

    plt.ioff()

    fig, ax1 = plt.subplots()
    ax2 = ax1.twinx()
    lines = []

    r = lambda: random.randint(0, 255)
    color_list = []
    num = iters_list.__len__()
    cmap = get_cmap(num*3)
    for i in range(num):
        for j in range(num):
            col = cmap(j*2)
            color_list.append(col)
        color = '#%02X%02X%02X' % (r(), r(), r())


    for i in range(loss_list.__len__()):
        line, = ax1.plot(iters_list[i], loss_list[i], label="{}".format(line_names[i]), color=color_list[i])
        lines.append(line)
    for i in range(acc_list.__len__()):
        line, = ax2.plot(iters_list[i], acc_list[i], label="{} Accuracy".format(line_names[i]), color=color_list[i])
        #lines.append(line)
    ax1.set_xlabel('Iterationen')
    ax1.set_ylabel('Loss', color='r')
    ax2.set_ylabel("Accuracy", color='b')

    #legend = plt.legend(handles=lines, bbox_to_anchor=(0., 1.02, 1., .102), loc=3,
    #           ncol=2, mode="expand", borderaxespad=0.)
    legend = plt.legend(handles=lines, bbox_to_anchor=(1.05, 1), loc=2,
                        borderaxespad=0.)
    print 'saving plot png to ' + args.output_png_path
    pylab.savefig(args.output_png_path, bbox_extra_artists=(legend,), bbox_inches='tight')
