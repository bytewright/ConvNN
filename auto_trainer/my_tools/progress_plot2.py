import os
import configargparse
import matplotlib as mpl
mpl.use('Agg')
import matplotlib.pyplot as plt
import pylab

csv_delimiter = ';'
iter_index = 0
acc_index = 1
loss_index = 3


def load_data(data_file):
    #delimiter = ';'
    test_data = []
    with open(data_file, 'r') as f:
        for line in f.readlines():
            line = line.rstrip()
            if line.split(csv_delimiter).__len__() < 3:
                print('incomplete line found')
            else:
                test_data.append([data for data in line.split(csv_delimiter) if data is not ''])

    return test_data[1:]


if __name__ == "__main__":
    configpath = os.path.join(os.path.dirname(__file__), 'plotter_config.ini')
    parser = configargparse.ArgParser(default_config_files=[configpath])
    parser.add_argument('--reference_data', help='path to reference test data, generated by caffe parse_log.py')
    parser.add_argument('--plot_data', help='path to test data, generated by caffe parse_log.py')
    parser.add_argument('--output_png_path', help='path to png, will be overwritten by this script')
    # parser.set_defaults(DEBUG=True)
    args = parser.parse_args()

    min_size = 99100000
    plot_datas = []
    ref_data = load_data(os.path.join(os.path.dirname(__file__), args.reference_data))
    plot_datas.append(ref_data)
    if int(ref_data[-1][0]) < min_size:
        print '{} is new min size'.format(int(ref_data[-1][0]))
        min_size = int(ref_data[-1][0])
    plot_data = load_data(args.plot_data)
    plot_datas.append(plot_data)
    if int(plot_data[-1][0]) < min_size:
        print '{} is new min size'.format(int(plot_data[-1][0]))
        min_size = int(plot_data[-1][0])

    # cut data to min size
    print 'min iters in data is:' + str(min_size)
    iters_list = []
    acc_list = []
    loss_list = []
    for data in plot_datas:
        list_min_iter_index = min_size
        if data[-1][0] > min_size:
            for i in range(data.__len__()):
                if int(data[i][0]) > min_size:
                    list_min_iter_index = i
                    break
                list_min_iter_index = i
        iterations = [int(x[iter_index]) for x in data[:list_min_iter_index]]
        accuracy = [x[acc_index] for x in data[:list_min_iter_index]]
        loss = [x[loss_index] for x in data[:list_min_iter_index]]
        iters_list.append(iterations)
        acc_list.append(accuracy)
        loss_list.append(loss)

    print 'found {} viable datapoints to plot'.format(min_size)

    plt.ioff()

    fig, ax1 = plt.subplots()
    ax2 = ax1.twinx()

    line1a, = ax1.plot(iters_list[0], loss_list[0], label="Test Loss", color='r')
    line1b, = ax1.plot(iters_list[1], loss_list[1], label="Referenz loss", color='#eb977f')
    line2a, = ax2.plot(iters_list[0], acc_list[0], label="Test Accuracy", color='b')
    line2b, = ax2.plot(iters_list[1], acc_list[1], label="Referenz Accuracy", color='#99cbe9')
    lines = [line1a, line1b, line2a, line2b]

    ax1.set_xlabel('Iterationen')
    ax1.set_ylabel('Loss', color='r')
    ax2.set_ylabel("Accuracy", color='b')

    legend = plt.legend(handles=lines, bbox_to_anchor=(1.05, 1), loc=2,
                        borderaxespad=0.)
    print 'saving plot png to ' + args.output_png_path
    pylab.savefig(args.output_png_path, bbox_extra_artists=(legend,), bbox_inches='tight')
